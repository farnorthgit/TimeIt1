#if 0
Write a class called StopWatch which measures time.
        Include a constructor which starts the clock,
            a Start method which can restart the clock
            and a Stop method which will record the end time for an event.
        Include two additional methods which will report the time in seconds and milliseconds as a double.
        Use the chronoheader from the Standard Template Library to get time from the system.
        Use it to test search, binary_search, and two other algorithms in the STL algorithm header to work on random integers or doubles created with the mt19937RNG.
        Measure the time for each algorithm –- at least five times each –- on groups of items ranging from 10, 100, 1K, 10K, 100K, 1M, 10M, 100M, and 1B.
        Take the output and graph it in Microsoft Excel, Gnuplot, Python with matplotlib, or R.
        What can you say about the comparative asymptotic performance for those algorithms?
#endif

#include <iostream>
using std::cout;
using std::endl;
#include "StopWatch.h"
#include <random>
#include <vector>
using std::vector;
#include <algorithm>
using std::find;

int main() {
    StopWatch timer;
    std::random_device rd;  // Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> dis(1, 10e7);
    int j = 10;

    for (int i=0; i<9; i++) {
        cout << j;
        vector<int> vv;
        vv.reserve(j);
        for (int n=0; n<j; n++) {
            //Use dis to transform the random unsigned int generated by gen into an int in [1, 10^7]
            vv.push_back(dis(gen));
        }
        int solution = dis(gen);
        timer.start();
        if (find(vv.begin(), vv.end(), solution) != vv.end()) {
            std::cout << "vv contains: " << solution << '\n';
        } else {
            std::cout << "v does not contain: " << solution << '\n';
        }
        timer.stop();
        cout << timer.milli() << endl;
        cout << timer.second() << endl;
        j = j * 10;
    }
}
